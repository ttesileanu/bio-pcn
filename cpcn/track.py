"""Define a class to track model tensors."""


import torch

from types import SimpleNamespace
from typing import Union, Iterable, Callable


def _dispatch_values(
    reporter: Callable,
    name: str,
    field: Union[str, dict],
    idx: int,
    value: Union[None, int, float, Iterable, torch.Tensor] = None,
    **kwargs,
):
    """Pass values to a reporter, handling lists or tensors, as well as dicts for
    multi-parameter reports.
    """
    if not isinstance(field, str):
        if value is not None:
            raise ValueError("Tracker: value used with multi-parameter report")

        for crt_key, crt_value in field.items():
            reporter(name, crt_key, idx, crt_value, **kwargs)
        return

    if not torch.is_tensor(value):
        if isinstance(value, int):
            value = torch.LongTensor([value])
        elif hasattr(value, "__iter__"):
            for i, sub_value in enumerate(value):
                reporter(name, f"{field}:{i}", idx, sub_value, **kwargs)
            return
        else:
            value = torch.FloatTensor([value])
    else:
        value = value.detach().cpu().clone()

    reporter(name, field, idx, value, **kwargs)


class _Reporter:
    """Helper for Tracker, used to report new values."""

    def __init__(self, tracker: "Tracker"):
        """Construct the reporter.
        
        :param tracker: associated tracker object
        """
        self._tracker = tracker

    def __getattr__(self, name: str):
        if self._tracker.finalized:
            raise ValueError("Tracker: attempt to report after finalize")

        # make a history field, if it does not exist
        if not hasattr(self._tracker.history, name):
            setattr(self._tracker.history, name, {})
        reporter = self._report
        return lambda *args, name=name, reporter=reporter, **kwargs: _dispatch_values(
            reporter, name, *args, **kwargs
        )

    def _report(
        self,
        name: str,
        field: Union[str, dict],
        idx: int,
        value: Union[None, int, float, Iterable, torch.Tensor] = None,
        meld: bool = False,
    ):
        if not meld:
            value.unsqueeze_(0)

        index_name = self._tracker.index_name
        target = getattr(self._tracker.history, name)
        for key in [index_name, field]:
            if key not in target:
                target[key] = []

        idxs = target[index_name]

        # try to make sure we don't have mismatched entries
        if len(target[field]) not in [len(idxs), len(idxs) - 1]:
            raise IndexError(
                "Tracker: mismatch in number of reports for different fields"
            )

        crt_idxs = torch.LongTensor(len(value) * [idx])
        if len(target[field]) == len(idxs):
            # add new index entry
            idxs.append(crt_idxs)
        else:
            # the index entry was already added
            # make sure the index is compatible with what we had before
            if len(crt_idxs) != len(idxs[-1]) or torch.any(crt_idxs != idxs[-1]):
                raise IndexError(
                    "Tracke: mismatch in index reported for different fields"
                )

        # add new history entry
        target[field].append(value)


class Tracker:
    """Tracker for tensor and list-of-tensor values.
    
    Call as
        tracker.report.test("field", idx, value)
    to add an entry in the `"field"` field of the `test` dictionary in the `history`.
    This adds the `value` to the `"field"`, and the given `idx` to the `"idx"` field
    inside `tracker.history.test`.

    If `value` is a `Tensor`, it is added as-is. If it is an iterable other than
    `Tensor`, it is considered "layered" variable. An entry is recorded for each of its
    elements, with field name generated by adding `":{layer}"` to `"field"`. Note that
    therefore there is a big difference in behavior between reporting the 2d tensor
        torch.FloatTensor([[1.0, 2.0, 3.0]])
    and reporting the list of tensors
        [torch.FloatTensor([1.0]), torch.FloatTensor([2.0]), torch.FloatTensor([3.0])] .

    Multiple values can be recorded at once by using a `dict` for the first argument:
        tracker.report.test({"foo": 2, "bar": 3}, idx=1)

    There is a way to submit several entries for the same index, which can be useful if
    we wish to, e.g., store a batch of results. This can be achieved by using the `meld`
    argument to `report`:
        tracker.report.test("field", idx, value, meld=True)
    If `value` is a tensor, a new entry is generated for each row in `value`. If it is a
    different iterable, then the same is done *per layer*. This will generate as many
    entries as the length of the tensors. The constraint here is that, if we store more
    than one field per namespace, all have to have the same batch size.
    """

    def __init__(self, index_name: str = "idx"):
        """Construct tracker.
        
        :param index_name: name of the index field
        """
        self.index_name = index_name
        self.history = SimpleNamespace()
        self.finalized = False
        self.report = _Reporter(self)

    def finalize(self):
        """Finalize recording, coalesce history into coherent tensors."""
        for field in self.history.__dict__:
            target = getattr(self.history, field)

            for key in target:
                # go through, find and process repeated entries
                if key != self.index_name:
                    for i, value in enumerate(target[key]):
                        if not torch.is_tensor(value):
                            sum = 0
                            for x in value:
                                sum = sum + x
                            target[key][i] = sum / len(value)

                # coalesce
                target[key] = torch.cat(target[key])

        self.finalized = True

    def set_index_name(self, index_name: str):
        """Set the name used as index."""
        self.index_name = index_name

    def __repr__(self) -> str:
        s = f"Tracker(index_name={self.index_name}, finalized={self.finalized}, "
        hist = "history=namespace("
        for i, name in enumerate(self.history.__dict__):
            if i > 0:
                hist += ", "
            sub_s = f"{name}={{" + ", ".join(
                f'"{_}"' for _ in getattr(self.history, name).keys()
            )
            hist += sub_s + "}"
        hist += ")"
        s += hist + ")"

        return s
